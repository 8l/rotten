* VM state
The VM has one piece of global state: the symbol table, which maps from global
variables to their values.

The VM has three piece of local state:
- I: The instruction list.
- E: The environment, an immutable array of closed-over values.
- S: The stack, which stores temporary values and continuations.

* Instructions
- (push LIT): pushes LIT onto S
- (pop): pops one element from S and ignores it
- (access N): pushes E[N] onto D
- (call N): calls S[N] with S[N-1..0] as arguments
- (closure ARITY REST-PARAM INSTRS): makes a closure and pushes it onto S
- (if THEN-INSTRS ELSE-INSTRS):
  pops S. if result is true, proceeds to THEN-INSTRS; otherwise, proceeds to ELSE-INSTRS.
  before proceeding, pushes a continuation.

- (get-global SYMBOL): pushes the value of SYMBOL in global environment onto D.
- (set-global SYMBOL): sets SYMBOL to S[0] in global environment.
  does NOT pop S; its "return value" is what it has set SYMBOL to.

* Builtins
builtin functions are implemented using a cheap trick. there are no special
instructions for them. rather, all of them except 'apply are just procedures in
the underlying implementation language (Racket). when a racket procedure is
"call"ed in the VM, the VM just calls it in the host language.

the 'apply builtin is different. (TODO: explain why it needs to be different to
avoid recursively entering VM.) when the symbol 'apply is called, the VM
interprets it specially. in the global environment, 'apply is bound to 'apply,
which makes this work "transparently".

* Functions
Functions/closures are structures with fields:
- arity: number of parameters (excluding rest parameter)
- has-rest-param: whether it has a rest parameter or not
- env: list representing closed-over environment
- instrs: the VM instruction list for the function's body

* Continuations
We use "continuations" to remember where to return to after finishing a function
or finishing one branch of an "if" instruction. A continuation has two fields:

- instrs: The instruction-stream (I) to return to.
- env: The environment (E) to restore.

The env field is only needed when returning from a function, not when finishing
an "if" instruction, but it is simpler to have only one form of a continuation.

* Environments
Our environment records our closed-over variables. Variables are accessed by
their index, so variable names are not needed in the VM. These indices
correspond roughly to DeBruijn indices. TODO: Explain DeBruijn indices.

However, there is the question of what order indices are assigned in a function
of multiple arguments:

    (fn (x y) (list x y))

In (list x y), what indices do x and y have?

Currently, I give x index 0 and y index 1. This is the opposite of what a
traditional "currying" implementation of multiple-argument functions would do. I
actually wrote the VM this way by accident; I may change it later.

For clarity, here is an example:

    (fn (a b) ((fn (x y) (list a b x y)) a b))

If we replace variables by their indices, this corresponds to:

    (fn (_ _) ((fn (_ _) (list 2 3 0 1)) 0 1))
