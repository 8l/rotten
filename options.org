TODO: write rotten->{clojure,scheme,racket} compiler in rotten

It actually doesn't matter much how difficult it is to implement rotten in
clojure/racket.

It matters how difficult it is to implement rotten in rotten.

So I should start by thinking about the semantics of rotten, and a mock
rotten-in-rotten implementation.

* metacircularly evaluate rotten
* compile rotten to clojure
* compile rotten to racket
* compile to a stack machine
let's design a simple stack machine!

stack machine has an
- I: instruction stream
- E: environment stack (for local vars)
- D: data stack (for arguments, return values, and return frames)

functions/closures are structures with fields:
- arity: number of parameters (excluding rest parameter)
- has-rest-param: whether it has a rest parameter or not
- env: list representing closed-over environment
- instrs: the VM instructions for the function

instructions:
- (push LIT): pushes LIT onto D
- pop: pops one element from D and ignores it
- (access N): pushes E(N) onto D
- (call N): calls D(N) with D(N-1..0) as arguments
- (closure ARITY REST-PARAM INSTRS): makes a closure and pushes it onto D
- (if THEN-INSTRS ELSE-INSTRS):
  pops D. if result is true, proceeds to THEN-INSTRS; otherwise, proceeds to ELSE-INSTRS.

- cons, car, cdr, set-car!, set-cdr!, symbol?, cons?, eq?:
  pop appropriate # of arguments, apply builtin function, push result.

- apply: pops an argument-list and a function from D, then applies the fn to the args.

- (set-global SYMBOL): sets SYMBOL to (pop D) in global environment.
- (get-global SYMBOL): pushes the value of SYMBOL in global environment onto D.

how do I implement assignables?
